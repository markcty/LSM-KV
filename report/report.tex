\documentclass{ctexart}

\title{LSM Tree实验报告}
\author{陈天予 519021910045}
\date{\today}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{enumitem}

\begin{document}

\maketitle

\section{背景介绍}
LSM Tree(Log-structure Merge Tree)数据结构，于1996年在Patrick O’Neil 等人的一篇论文提出。其通过SS-Table的多层储存结构，利用磁盘顺序读写的高效性，实现了性能极高的写操作。LSM Tree被广泛地在各种NoSQL中使用，比如HBase，LevelDB等。

\section{挑战}
\begin{enumerate}
  \item 持久化：之前写过的程序，数据结构都在内存中，很少涉及到文件的读写。LSM Tree通过客制化结构的SSTable实现持久化，需要通过二进制的方式来读写sst文件，因不熟悉c++相关的库函数而导致的bug就不少。
  \item sst文件的debug：由于sst文件在硬盘中，debug的过程中无法实时看到其中的数据，造成许多麻烦和障碍。最终写了一个peekSSTable的小程序扫描sst文件并输出debug信息，解决了debug时的困难。
\end{enumerate}

\section{测试}
\subsection{测试环境}
R7 3700x with SSD
\subsection{PUT测试}
\subsubsection{测试方法}
随机插入1000个大小在1 Byte到近2 MB大小的字符串，测试平均延时。连续测试三次，其中一次测试的结果如下：
\begin{verbatim}
  >>>>> Put Delay Test <<<<<
  0...100...200...300...400...500...600...700...800...900...
  Average Delay For Different Size Data: 
  0 ~ 0.25MB   : 4.50ms throughput: 222.41/s
  0.25MB ~ 1MB : 17.47ms throughput: 57.23/s
  0.5MB ~ 1MB  : 43.40ms throughput: 23.04/s
  1MB ~ 1.5MB  : 39.84ms throughput: 25.10/s
  1.5MB ~ 2MB  : 44.82ms throughput: 22.31/s
  Average Delay: 34.28ms Average Throughput: 29.17/s
  
  Total Size Insert: 979MB
  Total Time: 34s
\end{verbatim}

\subsubsection{预期结果}
每次测试平均延时近似，随着数据大小的上升，触发compaction的机率越大，延时也相应越大。

\subsubsection{实际结果}
\begin{tabular}{cc}
  \hline
  测试编号 & 平均延时 \\
  \hline
  1        & 31.692ms \\
  2        & 31.004ms \\
  3        & 30.934ms \\

  \hline
\end{tabular}

可见每次测试平均延时相似

\begin{tabular}{cccccc}
  \hline
  (MB) & 0-0.25 & 0.25-0.5 & 0.5-1.0 & 1-1.5 & 1.5-2.0 \\
  \hline
  (ms) & 4.50   & 17.72    & 31.69   & 41.87 & 40.52   \\

  \hline
\end{tabular}

可见随数据量增大，平均延时增加，但由于1MB以上的数据触发compaction的机率都较大，所以1MB以上的数据增加量不明显。

\end{document}